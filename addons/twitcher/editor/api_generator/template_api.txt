@tool
extends Node

# CLASS GOT AUTOGENERATED DON'T CHANGE MANUALLY. CHANGES CAN BE OVERWRITTEN EASILY.

## Interaction with the Twitch REST API.
class_name TwitchAPI

static var _log: TwitchLogger = TwitchLogger.new("TwitchAPI")

## Maximal tries to reauthrorize before giving up the request.
const MAX_AUTH_ERRORS = 3

## Called when the API returns unauthenticated mostly cause the accesstoken is expired
signal unauthenticated

## Called when the API returns 403 means there are permissions / scopes missing
signal unauthorized

## Broadcaster ID that will be used when no Broadcaster ID was given
@export var default_broadcaster_login: String:
	set(username):
		default_broadcaster_login = username
		_update_default_broadcaster_login(username)
		update_configuration_warnings()
	get():
		if default_broadcaster_login == null || default_broadcaster_login == "":
			return ""
		return default_broadcaster_login
## To authorize against the Twitch API
@export var token: OAuthToken
## OAuth settings needed for client information
@export var oauth_setting: OAuthSetting
## URI to the Twitch API
@export var api_host: String = "https://api.twitch.tv"

var broadcaster_user: TwitchUser:
	set(val):
		broadcaster_user = val
		notify_property_list_changed()

## Client to make HTTP requests
var client: BufferedHTTPClient

func _ready() -> void:
	client = BufferedHTTPClient.new()
	client.name = "ApiClient"
	add_child(client)
	if default_broadcaster_login == "" && token.is_token_valid():
		var current_user : TwitchGetUsersResponse = await get_users([],[])
		var user: TwitchUser = current_user.data[0]
		default_broadcaster_login = user.id


func _update_default_broadcaster_login(username: String) -> void:
	if not is_node_ready(): await ready
	var user_data : TwitchGetUsersResponse = await get_users([], [username])
	if user_data.data.is_empty():
		printerr("Username was not found: %s" % username)
		return
	broadcaster_user = user_data.data[0]


func _get_configuration_warnings() -> PackedStringArray:
	if default_broadcaster_login == null || default_broadcaster_login == "":
		return ["Please set default broadcaster that is used when no broadcaster was explicitly given"]
	return []
	
	
func request(path: String, method: int, body: Variant = "", content_type: String = "", error_count: int = 0) -> BufferedHTTPClient.ResponseData:
	var header : Dictionary = {
		"Authorization": "Bearer %s" % [await token.get_access_token()],
		"Client-ID": oauth_setting.client_id
	}
	if content_type != "":
		header["Content-Type"] = content_type

	var request_body: String = ""
	if body == null || (body is String && body == ""):
		request_body = ""
	elif body is Object && body.has_method("to_json"):
		request_body = body.to_json()
	else:
		request_body = JSON.stringify(body)

	var request = client.request(api_host + path, method, header, request_body)
	var response = await client.wait_for_request(request)

	# Token expired / or missing permissions
	if response.response_code == 403:
		_log.e("'%s' is unauthorized. It is probably your scopes." % path)
		unauthorized.emit()
	if response.response_code == 401:
		_log.i("'%s' is unauthenticated. Refresh token." % path)
		unauthenticated.emit()
		await token.authorized
		if error_count + 1 < MAX_AUTH_ERRORS:
			return await request(path, method, body, content_type, error_count + 1)
		else:
			# Give up the request after trying multiple times and
			# return an empty response with correct error code
			var empty_response = client.empty_response(request)
			empty_response.response_code = response.response_code
			return empty_response
	return response

{for methods as method}
{method}

{/for}

## Converts unix timestamp to RFC 3339 (example: 2021-10-27T00:00:00Z) when passed a string uses as is
static func get_rfc_3339_date_format(time: Variant) -> String:
	if typeof(time) == TYPE_INT:
		var date_time = Time.get_datetime_dict_from_unix_time(time)
		return "%s-%02d-%02dT%02d:%02d:%02dZ" % [date_time['year'], date_time['month'], date_time['day'], date_time['hour'], date_time['minute'], date_time['second']]
	return str(time)
